#!/bin/bash

# This script generates "fsdata.c" file for uIP 0.9 stack.
# It takes one argument - name of vendor directory,
# which should contains all www files, at least:
# - index.html (with: <input type="file" name="firmware">)
# - 404.html
# - flashing.hmtl
# - fail.html
#
# Files are processed with dedicated tools and then compressed with gzip -9n.
# HTML files with embedded JS/CSS are processed with careful preservation of styling.
# You SHOULDN'T embed addresses of any external
# files in "flashing.html" file, because web server,
# after receive POST data, returns this page and stops.

# Vendor specific directory (default: "pig")
vendor_dir=${1:-pig}

# Temporary files
files_content_tmp="vendors/.files_content"
files_list_tmp="vendors/.files_list"

# Check for specific tools
node_available=$(type -p node >/dev/null && echo 1 || echo 0)

# Check for specific tools
html_minifier_available=0
css_minifier_available=0
js_minifier_available=0

if [ $node_available -eq 1 ]; then
	if node -e "require('html-minifier')" 2>/dev/null; then
		html_minifier_available=1
	fi
	if node -e "require('clean-css')" 2>/dev/null; then
		css_minifier_available=1
	fi
	if node -e "require('terser')" 2>/dev/null; then
		js_minifier_available=1
	fi
fi

# Previous fsdata_file var name
prev_fsdata_struct="NULL"

# Files counter
files_counter=0

# Change ASCII to bytes, comma separated (e.g. "0x01, 0x02, 0x03...")
function ascii_to_bytes() {
	echo -ne $1 | od -A n -t x1 | tr -d '\r\n' | sed 's/ /0x/;s/ /, 0x/g;s/.\{102\}/&\n/g'
}

# Compress data using gzip and convert to hex
function compress_and_convert() {
	local _file="$1"
	local _compressed_data=$(gzip -c9n "$_file" | od -A n -t x1 | tr -d '\r\n' | sed 's/ /0x/;s/ /, 0x/g;s/.\{102\}/&\n/g')
	 echo "$_compressed_data"
}

# Advanced HTML minification with careful preservation of styling
function minify_html_with_preserved_styling() {
	local _input_file="$1"
	local _output_file="$2"

	if [ $html_minifier_available -eq 1 ]; then
		# Use html-minifier with options that preserve styling
		node -e "
		var minify = require('html-minifier').minify;
		var fs = require('fs');
		var content = fs.readFileSync('$1', 'utf8');
		var result = minify(content, {
			collapseWhitespace: true,
			removeComments: true,
			minifyCSS: true,
			minifyJS: true,
			removeRedundantAttributes: false,  // Keep attributes that might affect styling
			removeScriptTypeAttributes: false,
			removeStyleLinkTypeAttributes: false,
			sortAttributes: false,
			sortClassName: false,
			preserveLineBreaks: false,  // Preserve some line breaks to maintain layout
			collapseBooleanAttributes: true,
			removeEmptyAttributes: true,
			removeScriptTypeAttributes: true,
			removeStyleLinkTypeAttributes: true,
			minifyJS: {
				compress: {
					drop_console: true
				},
				mangle: true
			},
			minifyCSS: {
				level: {
					1: {all: true},
					2: {all: false}  // Don't aggressively optimize CSS to preserve styling
				}
			}
		});
		fs.writeFileSync('$2', result);
		"
	else
		# No dedicated tool available, copy original file
		cp "$_input_file" "$_output_file"
	fi
}

# Separate JS minification for standalone JS files
function minify_standalone_js() {
	local _input_file="$1"
	local _output_file="$2"

	if [ $js_minifier_available -eq 1 ]; then
		# Use terser for standalone JS files
		node -e "
		var Terser = require('terser');
		var fs = require('fs');
		var content = fs.readFileSync('$1', 'utf8');
		var result = Terser.minify(content, {compress: {drop_console: true}, mangle: true}).code;
		fs.writeFileSync('$2', result);
		"
	else
		# No dedicated tool available, copy original file
		cp "$_input_file" "$_output_file"
	fi
}

# Advanced CSS minification for standalone CSS files
function minify_standalone_css() {
	local _input_file="$1"
	local _output_file="$2"

	if [ $css_minifier_available -eq 1 ]; then
		# Use clean-css with conservative settings to preserve styling
		node -e "
		var CleanCSS = require('clean-css');
		var fs = require('fs');
		var content = fs.readFileSync('$1', 'utf8');
		var result = new CleanCSS({
			level: {
				1: {all: true},
				2: {
					all: true,
					mergeIntoShorthands: false,  // Conservative approach
					mergeMediaQueries: false
				}
			},
			format: 'beautify'  // Keep some formatting for readability
		}).minify(content);
		fs.writeFileSync('$2', result.styles);
		"
	else
		# No dedicated tool available, copy original file
		cp "$_input_file" "$_output_file"
	fi
}

# $1 -> file path
function print_data_array() {
	local _file_ext="${1##*.}"
	local _file_name="${1##*/}"
	local _file_name_no_ext="${_file_name%\.*}"
	local _file_content=""
	local _is_compressed=0

	# Open variable declaration
	`echo -ne "static const char data_"$_file_name_no_ext"_"$_file_ext"[] = {\n" >> "$files_content_tmp"`
	#`echo -ne "/* HTTP Header */\n" >> "$files_content_tmp"`

	# HTTP header (200 OK or 404 Not Found)
	if [ "$_file_name_no_ext" == "404"  ]; then
		`ascii_to_bytes "HTTP/1.0 404 File not found\r\n" >> "$files_content_tmp"`
	else
		`ascii_to_bytes "HTTP/1.0 200 OK\r\n" >> "$files_content_tmp"`
	fi

	# Server type
	`echo "," >> "$files_content_tmp"`
	`ascii_to_bytes "Server: uIP/0.9\r\n" >> "$files_content_tmp"`
	`echo "," >> "$files_content_tmp"`

	# Content - Process with dedicated tools and then gzip
	if [ "$_file_ext" == "css"  ]; then
		local _temp_file=$(mktemp)
		minify_standalone_css "$1" "$_temp_file"
		_file_content=$(compress_and_convert "$_temp_file")
		rm "$_temp_file"
		_is_compressed=1
		`ascii_to_bytes "Content-type: text/css; charset=UTF-8\r\n" >> "$files_content_tmp"`
	elif [ "$_file_ext" == "js" ]; then
		local _temp_file=$(mktemp)
		minify_standalone_js "$1" "$_temp_file"
		_file_content=$(compress_and_convert "$_temp_file")
		rm "$_temp_file"
		_is_compressed=1
		`ascii_to_bytes "Content-Type: application/javascript\r\n" >> "$files_content_tmp"`
	elif [ "$_file_ext" == "html"  ]; then
		local _temp_file=$(mktemp)
		# Special handling for HTML files with preserved styling
		minify_html_with_preserved_styling "$1" "$_temp_file"
		_file_content=$(compress_and_convert "$_temp_file")
		rm "$_temp_file"
		_is_compressed=1
		`ascii_to_bytes "Content-type: text/html; charset=UTF-8\r\n" >> "$files_content_tmp"`
	elif [ "$_file_ext" == "png"  ]; then
		# For binary files, just compress with gzip
		_file_content=$(compress_and_convert "$1")
		_is_compressed=1
		`ascii_to_bytes "Content-Type: image/png\r\n" >> "$files_content_tmp"`
	elif [ "$_file_ext" == "jpg" -o "$_file_ext" == "jpeg"  ]; then
		# For binary files, just compress with gzip
		_file_content=$(compress_and_convert "$1")
		_is_compressed=1
		`ascii_to_bytes "Content-Type: image/jpeg\r\n" >> "$files_content_tmp"`
	elif [ "$_file_ext" == "gif"  ]; then
		# For binary files, just compress with gzip
		_file_content=$(compress_and_convert "$1")
		_is_compressed=1
		`ascii_to_bytes "Content-Type: image/gif\r\n" >> "$files_content_tmp"`
	else
		# For other files, just compress with gzip
		_file_content=$(compress_and_convert "$1")
		_is_compressed=1
		`ascii_to_bytes "Content-type: text/html; charset=UTF-8\r\n" >> "$files_content_tmp"`
	fi

	# Add Content-Encoding header if compressed
	if [ $_is_compressed -eq 1 ]; then
		`echo "," >> "$files_content_tmp"`
		`ascii_to_bytes "Content-Encoding: gzip\r\n" >> "$files_content_tmp"`
	fi

	`echo "," >> "$files_content_tmp"`
	`ascii_to_bytes "\r\n" >> "$files_content_tmp"`
	`echo "," >> "$files_content_tmp"`

	# File content
	#`echo -ne "/* Page/File content (processed with preserved styling and gzip -c9n compressed) */\n" >> "$files_content_tmp"`
	`echo -ne "$_file_content" >> "$files_content_tmp"`

	# And close declaration
	`echo -ne ", 0 };\n\n" >> "$files_content_tmp"`
}

# $1 -> file path
function print_data_struct() {
	local _file_ext="${1##*.}"
	local _file_name="${1##*/}"
	local _file_name_no_ext="${_file_name%\.*}"

	`echo -ne "const struct fsdata_file file_"$_file_name_no_ext"_"$_file_ext"[] = {{\n" >> "$files_list_tmp"`
	`echo -ne "\t"$prev_fsdata_struct",\n" >> "$files_list_tmp"`
	`echo -ne "\t\"/$_file_name_no_ext.$_file_ext\",\n" >> "$files_list_tmp"`
	`echo -ne "\tdata_"$_file_name_no_ext"_"$_file_ext",\n" >> "$files_list_tmp"`
	`echo -ne "\t(int)sizeof(data_"$_file_name_no_ext"_"$_file_ext") - 1\n" >> "$files_list_tmp"`
	`echo -ne "}};\n\n" >> "$files_list_tmp"`

	prev_fsdata_struct="file_"$_file_name_no_ext"_"$_file_ext""
}

# === Main loop ===

if [ -d vendors/"$vendor_dir"  ]; then # If vendor dir exists
	# Remove old fsdata.c
	if [ -a "fsdata.c" ]; then
		`rm "fsdata.c"`
	fi

	`touch "$files_content_tmp" "$files_list_tmp"`

	# Loop through all files in vendor dir
	for file in vendors/"$vendor_dir"/*; do # For all found files
		print_data_array $file
		print_data_struct $file
		files_counter=$((files_counter+1))
	done

	# Add required defines
	`echo "#define FS_ROOT "$prev_fsdata_struct"" >> "$files_list_tmp"`
	`echo "#define FS_NUMFILES "$files_counter"" >> "$files_list_tmp"`

	# Generate new fsdata.c
	`touch "fsdata.c"`

	`cat "$files_content_tmp" > "fsdata.c"`
	`cat "$files_list_tmp" >> "fsdata.c"`

	`rm "$files_content_tmp" "$files_list_tmp"`
else
	echo "Error! Vendor specific directory (vendors/"$vendor_dir") doesn't exist!"
fi